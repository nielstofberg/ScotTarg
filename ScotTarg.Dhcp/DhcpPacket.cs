using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Text;
using System.Threading.Tasks;

namespace ScotTarg.Dhcp
{
    internal class DhcpPacket
    {
        private static readonly DhcpOption MAGIC_COOKIE = new DhcpOption((OptionCode)99, 130, new byte[] { 83, 99 });

        internal IPEndPoint RemoteEndPoint { get; set; }

        internal string ClientMACAddress
        {
            get
            {
                return BitConverter.ToString(CHAddr.SubArray(0, HLen)).Replace("-",":");
            }
        }

        internal DhcpMessageType MessageType
        {
            get
            {
                return (DhcpMessageType)((DhcpOption)Options.Where(r => r.Code == OptionCode.DHCPMessageType).ToArray()[0]).Data[0];
            }
        }

        internal string HostName
        {
            get
            {
                string rv = string.Empty;
                try
                {
                    byte[] data = ((DhcpOption)Options.Where(r => r.Code == OptionCode.HostName).ToArray()[0]).Data;
                    rv = Encoding.ASCII.GetString(data);
                }
                catch
                { }
                return rv;
            }
        }

        internal OptionCode[] ParameterRequestList
        {
            get
            {
                OptionCode[] data = new OptionCode[0];
                try
                {
                    byte[] dat = ((DhcpOption)Options.Where(r => r.Code == OptionCode.ParameterRequestList).ToArray()[0]).Data;
                    data = new OptionCode[dat.Length];
                    for (int x=0; x< data.Length; x++ )
                    {
                        data[x] = (OptionCode)dat[x];
                    }
                }
                catch
                { }
                return data;
            }
        }

        internal string AssignedIpAddress
        {
            get
            {
                return new IPAddress(YIAddr).ToString();
            }
        }

        /// <summary>
        /// Operation Code: Specifies the general type of message. 
        /// A value of 1 indicates a request message, while a value of 2 is a reply message.
        /// </summary>
        internal OperationalCode Op { get; set; }

        /// <summary>
        /// Hardware Type: Specifies the type of hardware of the local network
        /// </summary>
        internal HardwareType HType { get; set; }

        /// <summary>
        /// Hardware address length: Specifies how long hardware addresses are in 
        /// this message. For Ethernet or other networks using IEEE 802 MAC addresses, the value is 6.
        /// </summary>
        internal byte HLen { get; set; }

        /// <summary>
        /// Hops: Set to 0 by a client before transmitting a request and used by 
        /// relay agents to control the forwarding of BOOTP and/or DHCP messages.
        /// </summary>
        internal byte Hops { get; set; }

        /// <summary>
        /// ransaction Identifier: A 32-bit identification field generated by the client, 
        /// to allow it to match up the request with replies received from DHCP servers.
        /// </summary>
        internal UInt32 XId { get; set; }

        /// <summary>
        /// Seconds: In BOOTP this field was vaguely defined and not always used. 
        /// For DHCP, it is defined as the number of seconds elapsed since a client 
        /// began an attempt to acquire or renew a lease. This may be used by a busy 
        /// DHCP server to prioritize replies when multiple client requests are outstanding
        /// </summary>
        internal UInt16 Secs { get; set; }

        /// <summary>
        /// Flag indicating if the request was from a broadcast address.
        /// IE if the flag is set, the client does not know it's own address and the reply should be broadcast.
        /// </summary>
        internal Flag Flags { get; set; }

        /// <summary>
        /// Client IP Address [4 bytes]: The client puts its own current IP address in this field 
        /// if and only if it has a valid IP address while in the BOUND, RENEWING or REBINDING states; 
        /// otherwise, it sets the field to 0. The client can only use this field when its address 
        /// is actually valid and usable, not during the process of acquiring an address.
        /// </summary>
        internal byte[] CIAddr { get; set; }

        /// <summary>
        /// “Your” IP Address [4 bytes]: The IP address that the server is assigning to the client.
        /// </summary>
        internal byte[] YIAddr { get; set; }

        /// <summary>
        /// Server IP Address [4 bytes]: the address of the server that the client should use for the next 
        /// step in the bootstrap process, which may or may not be the server sending this reply.
        /// The sending server always includes its own IP address in the Server Identifier DHCP option.
        /// </summary>
        internal byte[] SIAddr { get; set; }

        /// <summary>
        /// Gateway IP Address [4 bytes]: This field is used just as it is in BOOTP, to route BOOTP messages 
        /// when BOOTP relay agents are involved to facilitate the communication of BOOTP requests and replies 
        /// between a client and a server on different subnets or networks. See the topic on DHCP relaying. 
        /// As with BOOTP, this field is not used by clients and does not represent the server giving the client 
        /// the address of a default router (that's done using the Router DHCP option).
        /// </summary>
        internal byte[] GIAddr { get; set; }

        /// <summary>
        /// Client Hardware Address: The hardware (layer two) address of the client, 
        /// which is used for identification and communication.
        /// </summary>
        internal byte[] CHAddr { get; set; }

        /// <summary>
        /// Server Name [64 bytes]: The server sending a DHCPOFFER or DHCPACK message may optionally put its name in this field. 
        /// This can be a simple text “nickname” or a fully-qualified DNS domain name (such as “myserver.organization.org”)
        /// This field may also be used to carry DHCP options, using the “option overload” feature, 
        /// indicated by the value of the DHCP Option Overload option.
        /// </summary>
        internal byte[] SName { get; set; }

        /// <summary>
        /// Boot Filename [128 bytes]: Optionally used by a client to request a particular type of boot file in a DHCPDISCOVER message. 
        /// Used by a server in a DHCPOFFER to fully specify a boot file directory path and filename.
        /// This field may also be used to carry DHCP options, using the “option overload” feature, 
        /// indicated by the value of the DHCP Option Overload option.
        /// </summary>
        internal byte[] File { get; set; }

        /// <summary>
        /// Options: Holds DHCP options, including several parameters required for basic DHCP operation.
        /// The last option in this array will have a code value of 255.
        /// </summary>
        internal DhcpOption[] Options { get; private set; }

        /// <summary>
        /// Default constructor
        /// </summary>
        internal DhcpPacket()
        {
            CIAddr = new byte[4];
            YIAddr = new byte[4];
            SIAddr = new byte[4];
            GIAddr = new byte[4];
            CHAddr = new byte[16];
            SName = new byte[64];
            File = new byte[128];
            Options = new DhcpOption[] { MAGIC_COOKIE };
        }

        /// <summary>
        /// Add a dhcp option to the array of options
        /// </summary>
        /// <param name="opt"></param>
        internal void AddOption(DhcpOption opt)
        {
            List<DhcpOption> opts = new List<Dhcp.DhcpOption>(Options);
            opts.Add(opt);
            Options = opts.ToArray();
        }

        internal byte[] GetBytes()
        {
            List<byte> ret = new List<byte>();
            ret.Add((byte)Op);
            ret.Add((byte)HType);
            ret.Add(HLen);
            ret.Add(Hops);
            ret.AddRange(XId.GetBytes());
            ret.AddRange(Secs.GetBytes());
            ret.AddRange(Flags.GetBytes());
            ret.AddRange(CIAddr);
            ret.AddRange(YIAddr);
            ret.AddRange(SIAddr);
            ret.AddRange(GIAddr);
            ret.AddRange(CHAddr);
            ret.AddRange(SName);
            ret.AddRange(File);
            foreach (DhcpOption opt in Options)
            {
                byte[] bts = opt.GetBytes();
                ret.AddRange(bts);
            }
            while (ret.Count < 299)
            {
                ret.Add(0x00);
            }
            ret.Add(0xff);
            return ret.ToArray();
        }

        /// <summary>
        /// Creates a new DhcpPacket of type Offer.
        /// Note the following fields have to be added after return:
        /// YIAddr, SIAddr, all options in ParameterRequestList
        /// </summary>
        /// <param name="orig"></param>
        /// <returns></returns>
        internal static DhcpPacket NewReplyPacket(DhcpPacket orig)
        {
            DhcpPacket ret = new Dhcp.DhcpPacket();
            ret.Op = OperationalCode.Reply;
            ret.HType = HardwareType.Ethernet;
            ret.HLen = orig.HLen;
            ret.Hops = 0;
            ret.XId = orig.XId;
            ret.Secs = 0;
            ret.Flags = Flag.Broadcast;
            ret.CHAddr = orig.CHAddr;

            return ret;
        }

        /// <summary>
        /// Take a data packet to parse and return a new instance of DhcpPacket
        /// </summary>
        /// <param name="data"></param>
        /// <returns></returns>
        internal static DhcpPacket Parse(byte[] data)
        {
            DhcpPacket packet = new Dhcp.DhcpPacket();
            packet.Op = (OperationalCode)data[0];
            packet.HType = (HardwareType)data[1];
            packet.HLen = data[2];
            packet.Hops = data[3];
            packet.XId = (UInt32)(data[4] << 24) | (UInt32)(data[5] << 16) | (UInt32)(data[6] << 8) | (UInt32)(data[7] << 0);
            packet.Secs = (UInt16)((UInt16)(data[8] << 8) | (UInt16)(data[9]));
            packet.Flags = (Flag)((UInt16)(data[10] << 8) | (UInt16)(data[11]));
            packet.CIAddr = data.SubArray(12, 4);
            packet.YIAddr = data.SubArray(16, 4);
            packet.SIAddr = data.SubArray(20, 4);
            packet.GIAddr = data.SubArray(24, 4);
            packet.CHAddr = data.SubArray(28, 16);
            packet.SName = data.SubArray(44, 64);
            packet.File = data.SubArray(108, 128);
            DhcpOption opt = new DhcpOption((OptionCode)data[236], (int)data[237], data.SubArray(238, 2));        
            if (opt != MAGIC_COOKIE)
            {
                throw new Exception("Not a valid DHCP Packet");
            }
            packet.AddOption(opt);
            int n = 240;
            while (data[n] != (byte)OptionCode.End)
            {
                if (data[n] != (byte)OptionCode.Pad)
                {
                    int len = data[n + 1];
                    packet.AddOption(new DhcpOption((OptionCode)data[n], len, data.SubArray(n + 2, len)));
                    n += len + 2;
                }
            }
            return packet;
        }


    }
}
